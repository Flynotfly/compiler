Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ARRAY
    BREAK
    CLASS
    COMMA
    COMMENT
    COMMENT_MULTI
    DIM
    ELSE
    EQUAL_EQUAL
    EXTENDS
    FOR
    GREATER_EQUAL
    GREATER_THAN
    IDENTIFIER
    IF
    IMPLEMENTS
    INTERFACE
    LEFT_BRACE
    LEFT_BRACKET
    LESS_EQUAL
    LESS_THAN
    MODULO
    NEW
    NEWARRAY
    NOT
    NOT_EQUAL
    NULL
    OR
    PERIOD
    PRINT
    READINTEGER
    READLINE
    RETURN
    RIGHT_BRACE
    RIGHT_BRACKET
    THIS
    VOID
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> decllist
Rule 2     decllist -> decl
Rule 3     decllist -> decllist decl
Rule 4     decl -> variabledecl
Rule 5     decl -> statement
Rule 6     variabledecl -> variabletype ID SEMICOLON
Rule 7     variabletype -> INT
Rule 8     variabletype -> DOUBLE
Rule 9     variabletype -> STRING
Rule 10    variabletype -> BOOL
Rule 11    statement -> ID EQUAL expression SEMICOLON
Rule 12    expression -> term
Rule 13    term -> factor
Rule 14    factor -> const
Rule 15    factor -> ID
Rule 16    const -> INT_CONST
Rule 17    const -> DOUBLE_CONST
Rule 18    const -> STRING_CONST
Rule 19    const -> BOOL_CONST
Rule 20    expression -> expression PLUS term
Rule 21    expression -> expression MINUS term
Rule 22    term -> term TIMES factor
Rule 23    term -> term DIVIDE factor
Rule 24    factor -> LEFT_PAREN expression RIGHT_PAREN

Terminals, with rules where they appear

AND                  : 
ARRAY                : 
BOOL                 : 10
BOOL_CONST           : 19
BREAK                : 
CLASS                : 
COMMA                : 
COMMENT              : 
COMMENT_MULTI        : 
DIM                  : 
DIVIDE               : 23
DOUBLE               : 8
DOUBLE_CONST         : 17
ELSE                 : 
EQUAL                : 11
EQUAL_EQUAL          : 
EXTENDS              : 
FOR                  : 
GREATER_EQUAL        : 
GREATER_THAN         : 
ID                   : 6 11 15
IDENTIFIER           : 
IF                   : 
IMPLEMENTS           : 
INT                  : 7
INTERFACE            : 
INT_CONST            : 16
LEFT_BRACE           : 
LEFT_BRACKET         : 
LEFT_PAREN           : 24
LESS_EQUAL           : 
LESS_THAN            : 
MINUS                : 21
MODULO               : 
NEW                  : 
NEWARRAY             : 
NOT                  : 
NOT_EQUAL            : 
NULL                 : 
OR                   : 
PERIOD               : 
PLUS                 : 20
PRINT                : 
READINTEGER          : 
READLINE             : 
RETURN               : 
RIGHT_BRACE          : 
RIGHT_BRACKET        : 
RIGHT_PAREN          : 24
SEMICOLON            : 6 11
STRING               : 9
STRING_CONST         : 18
THIS                 : 
TIMES                : 22
VOID                 : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

const                : 14
decl                 : 2 3
decllist             : 1 3
expression           : 11 20 21 24
factor               : 13 22 23
program              : 0
statement            : 5
term                 : 12 20 21 22 23
variabledecl         : 4
variabletype         : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . decllist
    (2) decllist -> . decl
    (3) decllist -> . decllist decl
    (4) decl -> . variabledecl
    (5) decl -> . statement
    (6) variabledecl -> . variabletype ID SEMICOLON
    (11) statement -> . ID EQUAL expression SEMICOLON
    (7) variabletype -> . INT
    (8) variabletype -> . DOUBLE
    (9) variabletype -> . STRING
    (10) variabletype -> . BOOL

    ID              shift and go to state 7
    INT             shift and go to state 8
    DOUBLE          shift and go to state 9
    STRING          shift and go to state 10
    BOOL            shift and go to state 11

    program                        shift and go to state 1
    decllist                       shift and go to state 2
    decl                           shift and go to state 3
    variabledecl                   shift and go to state 4
    statement                      shift and go to state 5
    variabletype                   shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> decllist .
    (3) decllist -> decllist . decl
    (4) decl -> . variabledecl
    (5) decl -> . statement
    (6) variabledecl -> . variabletype ID SEMICOLON
    (11) statement -> . ID EQUAL expression SEMICOLON
    (7) variabletype -> . INT
    (8) variabletype -> . DOUBLE
    (9) variabletype -> . STRING
    (10) variabletype -> . BOOL

    $end            reduce using rule 1 (program -> decllist .)
    ID              shift and go to state 7
    INT             shift and go to state 8
    DOUBLE          shift and go to state 9
    STRING          shift and go to state 10
    BOOL            shift and go to state 11

    decl                           shift and go to state 12
    variabledecl                   shift and go to state 4
    statement                      shift and go to state 5
    variabletype                   shift and go to state 6

state 3

    (2) decllist -> decl .

    ID              reduce using rule 2 (decllist -> decl .)
    INT             reduce using rule 2 (decllist -> decl .)
    DOUBLE          reduce using rule 2 (decllist -> decl .)
    STRING          reduce using rule 2 (decllist -> decl .)
    BOOL            reduce using rule 2 (decllist -> decl .)
    $end            reduce using rule 2 (decllist -> decl .)


state 4

    (4) decl -> variabledecl .

    ID              reduce using rule 4 (decl -> variabledecl .)
    INT             reduce using rule 4 (decl -> variabledecl .)
    DOUBLE          reduce using rule 4 (decl -> variabledecl .)
    STRING          reduce using rule 4 (decl -> variabledecl .)
    BOOL            reduce using rule 4 (decl -> variabledecl .)
    $end            reduce using rule 4 (decl -> variabledecl .)


state 5

    (5) decl -> statement .

    ID              reduce using rule 5 (decl -> statement .)
    INT             reduce using rule 5 (decl -> statement .)
    DOUBLE          reduce using rule 5 (decl -> statement .)
    STRING          reduce using rule 5 (decl -> statement .)
    BOOL            reduce using rule 5 (decl -> statement .)
    $end            reduce using rule 5 (decl -> statement .)


state 6

    (6) variabledecl -> variabletype . ID SEMICOLON

    ID              shift and go to state 13


state 7

    (11) statement -> ID . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 14


state 8

    (7) variabletype -> INT .

    ID              reduce using rule 7 (variabletype -> INT .)


state 9

    (8) variabletype -> DOUBLE .

    ID              reduce using rule 8 (variabletype -> DOUBLE .)


state 10

    (9) variabletype -> STRING .

    ID              reduce using rule 9 (variabletype -> STRING .)


state 11

    (10) variabletype -> BOOL .

    ID              reduce using rule 10 (variabletype -> BOOL .)


state 12

    (3) decllist -> decllist decl .

    ID              reduce using rule 3 (decllist -> decllist decl .)
    INT             reduce using rule 3 (decllist -> decllist decl .)
    DOUBLE          reduce using rule 3 (decllist -> decllist decl .)
    STRING          reduce using rule 3 (decllist -> decllist decl .)
    BOOL            reduce using rule 3 (decllist -> decllist decl .)
    $end            reduce using rule 3 (decllist -> decllist decl .)


state 13

    (6) variabledecl -> variabletype ID . SEMICOLON

    SEMICOLON       shift and go to state 15


state 14

    (11) statement -> ID EQUAL . expression SEMICOLON
    (12) expression -> . term
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (13) term -> . factor
    (22) term -> . term TIMES factor
    (23) term -> . term DIVIDE factor
    (14) factor -> . const
    (15) factor -> . ID
    (24) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (16) const -> . INT_CONST
    (17) const -> . DOUBLE_CONST
    (18) const -> . STRING_CONST
    (19) const -> . BOOL_CONST

    ID              shift and go to state 16
    LEFT_PAREN      shift and go to state 21
    INT_CONST       shift and go to state 22
    DOUBLE_CONST    shift and go to state 23
    STRING_CONST    shift and go to state 24
    BOOL_CONST      shift and go to state 25

    expression                     shift and go to state 17
    term                           shift and go to state 18
    factor                         shift and go to state 19
    const                          shift and go to state 20

state 15

    (6) variabledecl -> variabletype ID SEMICOLON .

    ID              reduce using rule 6 (variabledecl -> variabletype ID SEMICOLON .)
    INT             reduce using rule 6 (variabledecl -> variabletype ID SEMICOLON .)
    DOUBLE          reduce using rule 6 (variabledecl -> variabletype ID SEMICOLON .)
    STRING          reduce using rule 6 (variabledecl -> variabletype ID SEMICOLON .)
    BOOL            reduce using rule 6 (variabledecl -> variabletype ID SEMICOLON .)
    $end            reduce using rule 6 (variabledecl -> variabletype ID SEMICOLON .)


state 16

    (15) factor -> ID .

    TIMES           reduce using rule 15 (factor -> ID .)
    DIVIDE          reduce using rule 15 (factor -> ID .)
    SEMICOLON       reduce using rule 15 (factor -> ID .)
    PLUS            reduce using rule 15 (factor -> ID .)
    MINUS           reduce using rule 15 (factor -> ID .)
    RIGHT_PAREN     reduce using rule 15 (factor -> ID .)


state 17

    (11) statement -> ID EQUAL expression . SEMICOLON
    (20) expression -> expression . PLUS term
    (21) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 26
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 18

    (12) expression -> term .
    (22) term -> term . TIMES factor
    (23) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 12 (expression -> term .)
    PLUS            reduce using rule 12 (expression -> term .)
    MINUS           reduce using rule 12 (expression -> term .)
    RIGHT_PAREN     reduce using rule 12 (expression -> term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 19

    (13) term -> factor .

    TIMES           reduce using rule 13 (term -> factor .)
    DIVIDE          reduce using rule 13 (term -> factor .)
    SEMICOLON       reduce using rule 13 (term -> factor .)
    PLUS            reduce using rule 13 (term -> factor .)
    MINUS           reduce using rule 13 (term -> factor .)
    RIGHT_PAREN     reduce using rule 13 (term -> factor .)


state 20

    (14) factor -> const .

    TIMES           reduce using rule 14 (factor -> const .)
    DIVIDE          reduce using rule 14 (factor -> const .)
    SEMICOLON       reduce using rule 14 (factor -> const .)
    PLUS            reduce using rule 14 (factor -> const .)
    MINUS           reduce using rule 14 (factor -> const .)
    RIGHT_PAREN     reduce using rule 14 (factor -> const .)


state 21

    (24) factor -> LEFT_PAREN . expression RIGHT_PAREN
    (12) expression -> . term
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (13) term -> . factor
    (22) term -> . term TIMES factor
    (23) term -> . term DIVIDE factor
    (14) factor -> . const
    (15) factor -> . ID
    (24) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (16) const -> . INT_CONST
    (17) const -> . DOUBLE_CONST
    (18) const -> . STRING_CONST
    (19) const -> . BOOL_CONST

    ID              shift and go to state 16
    LEFT_PAREN      shift and go to state 21
    INT_CONST       shift and go to state 22
    DOUBLE_CONST    shift and go to state 23
    STRING_CONST    shift and go to state 24
    BOOL_CONST      shift and go to state 25

    expression                     shift and go to state 31
    term                           shift and go to state 18
    factor                         shift and go to state 19
    const                          shift and go to state 20

state 22

    (16) const -> INT_CONST .

    TIMES           reduce using rule 16 (const -> INT_CONST .)
    DIVIDE          reduce using rule 16 (const -> INT_CONST .)
    SEMICOLON       reduce using rule 16 (const -> INT_CONST .)
    PLUS            reduce using rule 16 (const -> INT_CONST .)
    MINUS           reduce using rule 16 (const -> INT_CONST .)
    RIGHT_PAREN     reduce using rule 16 (const -> INT_CONST .)


state 23

    (17) const -> DOUBLE_CONST .

    TIMES           reduce using rule 17 (const -> DOUBLE_CONST .)
    DIVIDE          reduce using rule 17 (const -> DOUBLE_CONST .)
    SEMICOLON       reduce using rule 17 (const -> DOUBLE_CONST .)
    PLUS            reduce using rule 17 (const -> DOUBLE_CONST .)
    MINUS           reduce using rule 17 (const -> DOUBLE_CONST .)
    RIGHT_PAREN     reduce using rule 17 (const -> DOUBLE_CONST .)


state 24

    (18) const -> STRING_CONST .

    TIMES           reduce using rule 18 (const -> STRING_CONST .)
    DIVIDE          reduce using rule 18 (const -> STRING_CONST .)
    SEMICOLON       reduce using rule 18 (const -> STRING_CONST .)
    PLUS            reduce using rule 18 (const -> STRING_CONST .)
    MINUS           reduce using rule 18 (const -> STRING_CONST .)
    RIGHT_PAREN     reduce using rule 18 (const -> STRING_CONST .)


state 25

    (19) const -> BOOL_CONST .

    TIMES           reduce using rule 19 (const -> BOOL_CONST .)
    DIVIDE          reduce using rule 19 (const -> BOOL_CONST .)
    SEMICOLON       reduce using rule 19 (const -> BOOL_CONST .)
    PLUS            reduce using rule 19 (const -> BOOL_CONST .)
    MINUS           reduce using rule 19 (const -> BOOL_CONST .)
    RIGHT_PAREN     reduce using rule 19 (const -> BOOL_CONST .)


state 26

    (11) statement -> ID EQUAL expression SEMICOLON .

    ID              reduce using rule 11 (statement -> ID EQUAL expression SEMICOLON .)
    INT             reduce using rule 11 (statement -> ID EQUAL expression SEMICOLON .)
    DOUBLE          reduce using rule 11 (statement -> ID EQUAL expression SEMICOLON .)
    STRING          reduce using rule 11 (statement -> ID EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 11 (statement -> ID EQUAL expression SEMICOLON .)
    $end            reduce using rule 11 (statement -> ID EQUAL expression SEMICOLON .)


state 27

    (20) expression -> expression PLUS . term
    (13) term -> . factor
    (22) term -> . term TIMES factor
    (23) term -> . term DIVIDE factor
    (14) factor -> . const
    (15) factor -> . ID
    (24) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (16) const -> . INT_CONST
    (17) const -> . DOUBLE_CONST
    (18) const -> . STRING_CONST
    (19) const -> . BOOL_CONST

    ID              shift and go to state 16
    LEFT_PAREN      shift and go to state 21
    INT_CONST       shift and go to state 22
    DOUBLE_CONST    shift and go to state 23
    STRING_CONST    shift and go to state 24
    BOOL_CONST      shift and go to state 25

    term                           shift and go to state 32
    factor                         shift and go to state 19
    const                          shift and go to state 20

state 28

    (21) expression -> expression MINUS . term
    (13) term -> . factor
    (22) term -> . term TIMES factor
    (23) term -> . term DIVIDE factor
    (14) factor -> . const
    (15) factor -> . ID
    (24) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (16) const -> . INT_CONST
    (17) const -> . DOUBLE_CONST
    (18) const -> . STRING_CONST
    (19) const -> . BOOL_CONST

    ID              shift and go to state 16
    LEFT_PAREN      shift and go to state 21
    INT_CONST       shift and go to state 22
    DOUBLE_CONST    shift and go to state 23
    STRING_CONST    shift and go to state 24
    BOOL_CONST      shift and go to state 25

    term                           shift and go to state 33
    factor                         shift and go to state 19
    const                          shift and go to state 20

state 29

    (22) term -> term TIMES . factor
    (14) factor -> . const
    (15) factor -> . ID
    (24) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (16) const -> . INT_CONST
    (17) const -> . DOUBLE_CONST
    (18) const -> . STRING_CONST
    (19) const -> . BOOL_CONST

    ID              shift and go to state 16
    LEFT_PAREN      shift and go to state 21
    INT_CONST       shift and go to state 22
    DOUBLE_CONST    shift and go to state 23
    STRING_CONST    shift and go to state 24
    BOOL_CONST      shift and go to state 25

    factor                         shift and go to state 34
    const                          shift and go to state 20

state 30

    (23) term -> term DIVIDE . factor
    (14) factor -> . const
    (15) factor -> . ID
    (24) factor -> . LEFT_PAREN expression RIGHT_PAREN
    (16) const -> . INT_CONST
    (17) const -> . DOUBLE_CONST
    (18) const -> . STRING_CONST
    (19) const -> . BOOL_CONST

    ID              shift and go to state 16
    LEFT_PAREN      shift and go to state 21
    INT_CONST       shift and go to state 22
    DOUBLE_CONST    shift and go to state 23
    STRING_CONST    shift and go to state 24
    BOOL_CONST      shift and go to state 25

    factor                         shift and go to state 35
    const                          shift and go to state 20

state 31

    (24) factor -> LEFT_PAREN expression . RIGHT_PAREN
    (20) expression -> expression . PLUS term
    (21) expression -> expression . MINUS term

    RIGHT_PAREN     shift and go to state 36
    PLUS            shift and go to state 27
    MINUS           shift and go to state 28


state 32

    (20) expression -> expression PLUS term .
    (22) term -> term . TIMES factor
    (23) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 20 (expression -> expression PLUS term .)
    PLUS            reduce using rule 20 (expression -> expression PLUS term .)
    MINUS           reduce using rule 20 (expression -> expression PLUS term .)
    RIGHT_PAREN     reduce using rule 20 (expression -> expression PLUS term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 33

    (21) expression -> expression MINUS term .
    (22) term -> term . TIMES factor
    (23) term -> term . DIVIDE factor

    SEMICOLON       reduce using rule 21 (expression -> expression MINUS term .)
    PLUS            reduce using rule 21 (expression -> expression MINUS term .)
    MINUS           reduce using rule 21 (expression -> expression MINUS term .)
    RIGHT_PAREN     reduce using rule 21 (expression -> expression MINUS term .)
    TIMES           shift and go to state 29
    DIVIDE          shift and go to state 30


state 34

    (22) term -> term TIMES factor .

    TIMES           reduce using rule 22 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 22 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 22 (term -> term TIMES factor .)
    PLUS            reduce using rule 22 (term -> term TIMES factor .)
    MINUS           reduce using rule 22 (term -> term TIMES factor .)
    RIGHT_PAREN     reduce using rule 22 (term -> term TIMES factor .)


state 35

    (23) term -> term DIVIDE factor .

    TIMES           reduce using rule 23 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 23 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 23 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 23 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 23 (term -> term DIVIDE factor .)
    RIGHT_PAREN     reduce using rule 23 (term -> term DIVIDE factor .)


state 36

    (24) factor -> LEFT_PAREN expression RIGHT_PAREN .

    TIMES           reduce using rule 24 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    DIVIDE          reduce using rule 24 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    SEMICOLON       reduce using rule 24 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    PLUS            reduce using rule 24 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    MINUS           reduce using rule 24 (factor -> LEFT_PAREN expression RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 24 (factor -> LEFT_PAREN expression RIGHT_PAREN .)

